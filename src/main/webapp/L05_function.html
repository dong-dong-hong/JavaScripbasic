<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>자바스크립트의 함수</title>
</head>
<body>
<h1>연산의 집합 함수(method)</h1>
<h2>함수 선언과 사용법</h2>
<ul>
    <li>function 이름(매개변수){return 반환값;} : 작성법</li>
    <li>이름(매개변수); : 호출법</li>
    <li>이름(undefined); : 매개변수가 있는데 안쓰면 undefined가 된다.</li>
    <li>return; : 을 작성하면 다음코드가 있어도 함수를 종료한다.</li>
    <li>매개변수 : let을 사용할 필요없다.</li>
    <li>함수를 선언하면 실행전에 인터프리터 엔지(v8)이 타입인 줄 알고 미리 프로토 타입을 만든다.
        (호이스팅 현상이 발생)
    </li>
</ul>
<h2>함수의 선언법2</h2>
<ul>
    <li>const 함수이름=function(매개변수){} : 이름이 없는 함수를 변수 or 상수가 참조</li>
    <li>인터프리터 엔진이 함수를 찾지못해서 미리 프로토타입을 만들지 않는다.
        (해당 코드가 실행될 때까지 함수는 미리 만들어 지지 않는다.)
    </li>
    <li>사람들이 왜 함수가 나중에 선언됐는데 그 앞에서 호출되는가? 오류아닌가? -> 오류를 막으려고 등장한 방식</li>
    <li>함수 선언이 너무 많으면 js 실행이 너무 느려져서 우선 실행하면서 함수가 선언되게 하기 위해 사용됨</li>
</ul>
<h2>함수의 선언법 3</h2>
<ul>
    <li>const 함수이름 =()=>{return 반환값;} : 화살표 함수를 변수 or 상수가 참조</li>
    <li>()->{} : 실행만될 함수를 타입을 인지하는 js의 문제를 해결하기 위해 일반함수로 화살표 함수를 도입(es6)</li>
    <li>모든 함수를 프로토타입으로 인지하면 메모리를 많이 사용하기 때문에 문제가 발생할 수 있다.</li>
    <li>함수와 필드 바이딩문제로 화살표함수가 등장! (수업이 따로 있다.)</li>
</ul>
<script>
    /* java
      class Calc{
       public int sum(int a, int b) {
        return a + b;
       }
      }
    */

    // js의 함수 규칙
    console.log(sum(30)); // 30 +NaN
    console.log(sum(30, 40))
    // console.log(sum2(30,40))
    // console.log(sum3(30,40))
    const sum3 = (a, b) => { // js의 화살표함수
        return a + b;
    }// 프로토타입이 없는 일반 함수(타입이 될 수 없다. 순수한 실행의 함수이다.)
    console.log(sum3(30, 40))


    // 이름이 없는 함수를 변수가 참조하는 법 (선언하고 나서 사용가능 : 함수의 호이스팅 현상을 막기위해)
    const sum2 = function (a, b) {
        return a + b;
    }
    console.log(sum2(30, 40));
    // 함수를 정의하면서 이름을 짓는 법 (어디서든 선언해도 사용가능 함수의 Hoisting 현상)
    // 함수는 프로토타입이기 때문에 v8엔진이 함수만 찾아서 메모리에 생성 후 저장한다.
    // JVM 실행하기 전에 모든 클래스와 함수를 메소드 영역에 저장
    function sum(a, b) {
        return a + b
    }

    console.log(`sum(10,11)=${sum(10, 11)}`)

    function Calc() {
        this.sum = function (a, b) { // this 필드접근장 : 해당 타입이 객체일 때 필드접근
            return a + b;
        }
    }

    // Calc.sum()으로 10+11의 결과를 출력하세요.
    console.log(`new Calc().sum(10,11) = ${new Calc().sum(10, 11)}`)

    console.log(sum.prototype);
    console.log(sum2.prototype);
    console.log(sum3.prototype);
    // 화살표함수는 프로토타입이 없는 순수 method다!
</script>
</body>
</html>